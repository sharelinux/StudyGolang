## 费曼笔记 ##
#### Channel 通道特性
一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。


#### 通道基本特性如下:
1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
2. 发送操作和接收操作中对元素值的处理都是不可分割的。
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

##### 通道特性详解
1. 在同一时刻，Go语言的运行时系统,只会执行对同一个通道的任意个发送操作中的某一个。
2. 在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。
3. 对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。
4. 注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。
5. 元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，
    5.1 第一步是生成正在通道中的这个元素值的副本，并准备给到接收方
    5.2 第二步是删除在通道中的这个元素值。
6. 一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。
> 在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。
7. 接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。
8. 在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。

#### go中最重要的一种通信通道就是channel
1.给一个 nil channel 发送数据，造成永远阻塞
2.从一个 nil channel 接收数据，造成永远阻塞
3.给一个已经关闭的 channel 发送数据，引起 panic
4.从一个已经关闭的 channel 接收数据，立即返回一个零值


#### 思考问题
1. 发送操作和接收操作在什么时候可能被长时间的阻塞？
答：
    1. 缓冲通道
        - 针对缓冲通道的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
        - 如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。
    2. 非缓冲通道
        - 无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。
        - 由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。
    3. 错误使用通道
        - 对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。
注意，由于通道类型是引用类型，所以它的零值就是nil。换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。我们一定不要忘记初始化通道！

2. 发送操作和接收操作在什么时候会引发 panic？
答:
    1. 通道一旦关闭，再对它进行发送操作, 就会引发panic;
    2. 试图关闭一个已经关闭的通道，也会引发panic.
        > 注意：接收操作是可以感知到通道的关闭的，并能够安全退出。

#### 思考题

1. 通道的长度代表着什么？它在什么时候会通道的容量相同？
答:
    - 非缓冲通道 长度=容量
    - 缓冲通道 len代表通道中已存入的元素数量，cap代表整个缓冲区的大小
    - 缓冲通道 当缓冲通道已满的时候，长度=容量

2. 元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢？
答: 浅表复制


参考链接1: https://gobyexample.com/goroutines