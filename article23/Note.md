# 费曼笔记 ##
## 测试的基本规则和流程 (上)

#### 程序测试的重要性

  对于程序和软件来讲，尽早发现问题、修正问题其实非常重要。
  
  越是人们关注和喜爱的程序，它的测试（尤其是自动化的测试）做得就越充分，测试流程就越规范。
  
  对于优良的程序和软件来说，测试必然是非常受重视的一个环节。
  
### 程序软件测试分类
  - 单元测试
  - API测试
  - 集成测试
  - 灰度测试


### 单元测试
单元测试，它又称程序员测试。顾名思义，这就是程序员们本该做的自我检查工作之一。
  
  在 Go 语言中，一个测试用例往往会由一个或多个测试函数来代表，不过在大多数情况下，每个测试用例仅用一个测试函数就足够了。测试函数往往用于描述和保障某个程序实体的某方面功能，比如，该功能在正常情况下会因什么样的输入，产生什么样的输出，又比如，该功能会在什么情况下报错或表现异常，等等。


### Go 程序编写三类测试
  - 功能测试（test）
  - 基准测试（benchmark，也称性能测试）
  - 示例测试（example）
  
  对于前两类测试，从名称上你就应该可以猜到它们的用途。而示例测试严格来讲也是一种功能测试，只不过它更关注程序打印出来的内容。


#### 测试源码文件的主名称规则
测试源码文件的主名称应该以被测源码文件的主名称为前导，并且必须以“_test”为后缀。

  例如，如果被测源码文件的名称为 demo52.go，那么针对它的测试源码文件的名称就应该是 demo52_test.go。


#### 测试源码文件注意事项
  每个测试源码文件都必须至少包含一个测试函数。并且，从语法上讲，每个测试源码文件中，都可以包含用来做任何一类测试的测试函数，即使把这三类测试函数都塞进去也没有问题。我通常就是这么做的，只要把控好测试函数的分组和数量就可以了。
  
  可以依据这些测试函数针对的不同程序实体，把它们分成不同的逻辑组，并且，利用注释以及帮助类的变量或函数来做分割。同时，我们还可以依据被测源码文件中程序实体的先后顺序，来安排测试源码文件中测试函数的顺序。


### Go 语言对测试函数的名称和签名都有哪些规定？
  - 对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表中只应有一个*testing.T类型的参数声明。
  - 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一参数的类型必须是*testing.B类型的。
  - 对于示例测试函数来说，其名称必须以Example为前缀，但对函数的参数列表没有强制规定。
  

### go test命令执行的主要测试流程是什么？  

1. 首先需要记住一点，只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行go test命令的时候，其中的测试代码才有可能被运行。
2. go test命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给予的标记是否合法，等等。
3. 在准备工作顺利完成之后，go test命令就会针对每个被测代码包，依次地进行构建、执行包中符合要求的测试函数，清理临时文件，打印测试结果。这就是通常情况下的主要测试流程。


#### go test 测试流程细节
  为了加快测试速度，它通常会并发地对多个被测代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，这会让我们感觉到它是在完全串行地执行测试流程。
  
  由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的。更具体地说，只有在所有构建步骤都做完之后，go test命令才会真正地开始进行性能测试。
  
  下一个代码包性能测试的进行，总会等到上一个代码包性能测试的结果打印完成才会开始，而且性能测试函数的执行也都会是串行的。


### 你还知道或用过testing.T类型和testing.B类型的哪些方法？它们都是做什么用的？
#### testing.T
  - 判定失败接口
    - Fail失败继续
    - FailNow 失败终止
      - 打印信息接口
      - Log 数据流（cout　类似）
      - Logf format (printf 类似）
    - SkipNow 跳过当前测试
    - Skiped 检测是否跳过

```go
func TestPrint(t *testing.T) {
    // 输出测试日志
    t.Logf()
    // 标记错误，但仍然执行后面的语句
    t.Fail()
    // 获取是否当前用例是执行错误的
    t.Failed()
    // 错误输出，等于 t.Logf 再执行 t.Fail()
    t.Errorf("%s", "run ErrorF")
    // 标记函数错误，并中断后面的执行
    t.FailNow()
    // 致命错误输出，等同于调用了 t.Logf 然后调用 t.FailNow()
    t.Fatalf("%s", "run Fatelf")
    
    // 获取测试用例名称
    t.Name()
    // 运行子测试用例
    t.Run()
    // 跳过后面的内容，后面将不再运行
    t.SkipNow()
    // 告知当前的测试是否已被忽略
    t.Skipped()
    // 并行测试
    t.Parallel()
}    
```

#### 综合接口产生：
    - Error / Errorf 报告出错继续 [ Log / Logf + Fail ]
    - Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]
    - Skip / Skipf报告并跳过 [ Log / Logf + SkipNow ]


#### testing.B
    - testing.B                            拥有testing.T 的全部接口。
    - SetBytes( i uint64)                  统计内存消耗， 如果你需要的话。
    - SetParallelism(p int)                制定并行数目。
    - StartTimer / StopTimer / ResertTimer 操作计时器
    
### 参考
- 参考: https://www.jianshu.com/p/57105852dd89
- 参考: https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter09/09.1.html