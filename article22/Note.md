## 费曼笔记 ##
### panic函数、recover函数以及defer语句 (下)

#### 基础概念
##### defer语句
defer语句就是被用来延迟执行代码的。延迟到什么时候呢？这要延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。

#### 怎样让 panic 包含一个值，以及应该让它包含什么样的值？

    在调用panic函数时，把某个值作为参数传给该函数就可以了。由于panic函数的唯一一个参数是空接口（也就是interface{}）类型的，所以从语法上讲，它可以接受任何类型的值。
    
    最好传入error类型的错误值，或者其他的可以被有效序列化的值。这里的“有效序列化”指的是，可以更易读地去表示形式转换。
    
    error类型值的Error方法与其他类型值的String方法是等价的，它们的唯一结果都是string类型的。
    
    一旦程序异常了，我们就一定要把异常的相关信息记录下来，这通常都是记到程序日志里。
    我们在为程序排查错误的时候，首先要做的就是查看和解读程序日志；而最常用也是最方便的日志记录方式，就是记下相关值的字符串表示形式。
    
    最好自己定义的Error方法或者String方法。因此，为不同的数据类型分别编写这两种方法总是首选。
    
    可以施加某种保护措施，避免程序的崩溃。这个时候，panic 包含的值会被取出，而在取出之后，它一般都会被打印出来或者记录到日志里。
    
    
#### 怎样施加应对 panic 的保护措施，从而避免程序崩溃？

    Go 语言的内建函数recover专用于恢复 panic，或者说平息运行时恐慌。recover函数无需任何参数，并且会返回一个空接口类型的值。
    
    panic 一旦发生，控制权就会讯速地沿着调用栈的反方向传播。所以，在panic函数调用之后的代码，根本就没有执行的机会。
     
    如果在我们调用recover函数时未发生 panic，那么该函数就不会做任何事情，并且只会返回一个nil。 
    
    defer在在这里被调用的函数可以是有名称的，也可以是匿名的。我们可以把这里的函数叫做defer函数或者延迟函数。注意，被延迟执行的是defer函数，而不是defer语句。
    
    论函数结束执行的原因是什么，其中的defer函数调用都会在它即将结束执行的那一刻执行。即使导致它执行结束的原因是一个 panic 也会是这样。正因为如此，我们需要联用defer语句和recover函数调用，才能够恢复一个已经发生的 panic。
    
    注意，我们要尽量把defer语句写在函数体的开始处，因为在引发 panic 的语句之后的所有语句，都不会有任何执行机会。


#### 如果一个函数中有多条defer语句，那么那几个defer函数调用的执行顺序是怎样的？

    在同一个函数中，defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反。
    
    在defer语句每次执行的时候，Go 语言会把它携带的defer函数及其参数值另行存储到一个队列中。
    
    这个队列与该defer语句所属的函数是对应的，并且，它是先进后出（FILO）的，相当于一个栈。
    

#### 总结

- 对recover函数的调用只有在defer语句中才能真正起作用。defer语句是被用来延迟执行代码的。
- 在同一个函数中，延迟执行的defer函数调用，会与它们分别所属的defer语句的执行顺序完全相反。还要注意，同一条defer语句每被执行一次，就会产生一个延迟执行的defer函数调用。