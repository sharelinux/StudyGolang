## 费曼笔记 ##

> Go 语言的代码块是一层套一层的，就像大圆套小圆。一个代码块可以有若干个子代码块；但对于每个代码块，最多只会有一个直接包含它的代码块，后者可以简称为前者的外层代码块。

#### 程序实体的访问权限有三种: 
    包级私有的、模块级私有的和公开的。

    前两种访问权限对应的都是代码包代码块，最后一种访问权限对应的是全域代码块。

#### 作用域: 
一个程序实体的作用域总是会被限制在某个代码块中。而这个作用域最大的用处，就是对程序实体的访问权限的控制。对“高内聚，低耦合”这种程序设计思想的实践.


#### 变量查找过程: 
    1. 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
    2. 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。
    3. 一般情况下，程序会一直查到当前代码包代表的那层代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。
    

#### 不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？
    1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间的由相同的标识符代表的变量。
    2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
    3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。
    4. 如果可重名变量所在的代码块之间存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

#### 总结:
  - 可重名变量 
    注意: 在同一个代码块中是不允许出现重名的变量的，这违背了 Go 语言的语法。在多个代码块之间的由相同的标识符代表的变量。可重名变量之间不存在类似的限制，它们的类型可以是任意的。可重名变量所在的代码块之间存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。

  - 变量重声明
    注意: 变量重声明中的变量一定是在某一个代码块内的，不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。