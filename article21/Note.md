## 费曼笔记 ##
### panic函数、recover函数以及defer语句 (上)

#### 基础概念

> 程序异常被叫做 panic，我把它翻译为运行时恐慌。其中的“恐慌”二字是由 panic 直译过来的，而之所以前面又加上了“运行时”三个字，是因为这种异常只会在程序运行的时候被抛出来。

在 Go 语言中，因 panic 导致程序结束运行的退出状态码一般都会是2。

#### 从 panic 被引发到程序终止运行的大致过程是什么？

    某个函数中的某行代码有意或无意地引发了一个 panic。这时，初始的 panic 详情会被建立起来，并且该程序的控制权会立即从此行代码转移至调用其所属函数的那行代码上，也就是调用栈中的上一级。
    
    这也意味着，此行代码所属函数的执行随即终止。紧接着，控制权并不会在此有片刻停留，它又会立即转移至再上一级的调用代码处。控制权如此一级一级地沿着调用栈的反方向传播至顶端，也就是我们编写的最外层函数那里。
    
    这里的最外层函数指的是go函数，对于主 goroutine 来说就是main函数。但是控制权也不会停留在那里，而是被 Go 语言运行时系统收回。
    
    随后，程序崩溃并终止运行，承载程序这次运行的进程也会随之死亡并消失。与此同时，在这个控制权传播的过程中，panic 详情会被逐渐地积累和完善，并会在程序终止之前被打印出来。
    
#### 错误和异常的异同
##### 错误
注意，这与从函数返回错误值的意义是完全不同的。当我们的函数返回一个非nil的错误值时，函数的调用方有权选择不处理，并且不处理的后果往往是不致命的。

这里的“不致命”的意思是，不至于使程序无法提供任何功能（也可以说僵死）或者直接崩溃并终止运行（也就是真死）。

##### 异常
当一个 panic 发生时，如果我们不施加任何保护措施，那么导致的直接后果就是程序崩溃，就像前面描述的那样，这显然是致命的。


#### 异常传递方式
panic 详情会在控制权传播的过程中，被逐渐地积累和完善，并且，控制权会一级一级地沿着调用栈的反方向传播至顶端。

针对某个 goroutine 的代码执行信息中，调用栈底端的信息会先出现，然后是上一级调用的信息，以此类推，最后才是此调用栈顶端的信息。


#### 异常处理的场景:
1. 空指针引用
2. 下标越界
3. 除数为0
4. 不应该出现的分支，比如default
5. 输入不应该引起函数错误


#### 异常处理的正确姿势
1. 姿势一：在程序开发阶段，坚持速错;
    
    在早期开发以及任何发布阶段之前，最简单的同时也可能是最好的方法是调用panic函数来中断程序的执行以强制发生错误，使得该错误不会被忽略，因而能够被尽快修复。

2. 姿势二：在程序部署后，应恢复异常避免程序终止

    Goroutine如果panic了，并且没有recover，那么整个Golang进程就会异常退出。所以，一旦Golang程序部署后，在任何情况下发生的异常都不应该导致程序异常退出，我们在上层函数中加一个延迟执行的recover调用来达到这个目的，并且是否进行recover需要根据环境变量或配置文件来定，默认需要recover。
    
    在调用recover的延迟函数中以最合理的方式响应该异常：
    
    - 打印堆栈的异常调用信息和关键的业务信息，以便这些问题保留可见；
    - 将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。
    - 原因是panic异常处理机制不会自动将错误信息传递给error，所以要在函数中进行显式的进行转化和传递;
    
3. 对于不应该出现的分支，使用异常处理
    
    当某些不应该发生的场景发生时，我们就应该调用panic函数来触发异常。比如，当程序到达了某条逻辑上不可能到达的路径

4. 针对入参不应该有问题的函数，使用panic设计

    入参不应该有问题一般指的是硬编码，我们先看“一个启示”一节中提到的两个函数（Compile和MustCompile），其中MustCompile函数是对Compile函数的包装；
    

#### 参考: 
参考1: https://www.jianshu.com/p/f30da01eea97